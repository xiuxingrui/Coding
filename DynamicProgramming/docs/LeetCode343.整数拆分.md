# [LeetCode343.整数拆分](https://leetcode-cn.com/problems/integer-break/)
## 题目描述
给定一个正整数 `n`，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

说明: 你可以假设 `n` 不小于 2 且不大于 58。
### 示例
```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```
```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```
## 题解
对于的正整数 `n`，当 `n≥2` 时，可以拆分成至少两个正整数的和。令 `k` 是拆分出的第一个正整数，则剩下的部分是 `n−k` 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。

创建数组 `dp`，其中 `dp[i]` 表示将正整数 `i` 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 `dp[0]=dp[1]=0`。

当 `i≥2` 时，假设对正整数 `i` 拆分出的第一个正整数是 `j`（`1≤j<i`），则有以下两种方案：

- 将 `i` 拆分成 `j` 和 `i−j` 的和，且 `i−j` 不再拆分成多个正整数，此时的乘积是 `j×(i−j)`；
- 将 `i` 拆分成 `j` 和 `i−j` 的和，且 `i−j` 继续拆分成多个正整数，此时的乘积是 `j×dp[i−j]`。

因此，当 `j` 固定时，有 `dp[i]=max(j×(i−j),j×dp[i−j])`。由于 `j` 的取值范围是 1 到 `i−1`，需要遍历所有的 `j` 得到 `dp[i]` 的最大值，因此可以得到状态转移方程如下：

![](https://picgp.oss-cn-beijing.aliyuncs.com/img/20200902215540.png)

最终得到 `dp[n]` 的值即为将正整数 `n` 拆分成至少两个正整数的和之后，这些正整数的最大乘积。

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp=new int[n+1];
        dp[0]=0;
        dp[1]=0;
        for(int i=2;i<=n;i++){
            for(int j=1;j<i;j++){
                dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```
#### 复杂度分析
- 时间复杂度：$O(n^2)$，其中 `n` 是给定的正整数。对于从 2 到 `n` 的每一个整数都要计算对应的 `dp` 值，计算一个整数对应的 `dp` 值需要 $O(n)$ 的时间复杂度，因此总时间复杂度是 $O(n^2)$。
- 空间复杂度：$O(n)$，其中 `n` 是给定的正整数。创建一个数组 `dp`，其长度为 `n+1`。





